<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>2d6 Distribution Tracker</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;700;800&display=swap');

  :root {
    --bg: #0e0e12;
    --panel: #16161e;
    --border: #2a2a3a;
    --accent: #f0c040;
    --accent2: #e05050;
    --bell: rgba(240,192,64,0.12);
    --text: #d8d8e8;
    --muted: #666680;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Space Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 32px 16px;
    gap: 24px;
  }

  h1 {
    font-family: 'Syne', sans-serif;
    font-weight: 800;
    font-size: clamp(1.6rem, 4vw, 2.6rem);
    letter-spacing: -0.02em;
    color: var(--accent);
    text-align: center;
  }

  .subtitle {
    color: var(--muted);
    font-size: 0.75rem;
    text-align: center;
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  .card {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 24px;
    width: 100%;
    max-width: 860px;
  }

  .input-row {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }

  .input-row label {
    font-size: 0.8rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  .num-grid {
    display: grid;
    grid-template-columns: repeat(11, 1fr);
    gap: 8px;
    width: 100%;
    max-width: 860px;
  }

  .die-btn {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text);
    font-family: 'Syne', sans-serif;
    font-weight: 700;
    font-size: 1rem;
    padding: 14px 0;
    cursor: pointer;
    transition: all 0.12s;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
  }

  .die-btn span.label { font-size: 1.1rem; }
  .die-btn span.count {
    font-family: 'Space Mono', monospace;
    font-size: 0.65rem;
    color: var(--muted);
  }

  .die-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(240,192,64,0.15);
  }

  .die-btn:active { transform: translateY(0); }

  canvas {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 8px;
  }

  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 12px;
  }

  .stat {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 12px;
    text-align: center;
  }

  .stat .val {
    font-family: 'Syne', sans-serif;
    font-size: 1.5rem;
    font-weight: 800;
    color: var(--accent);
  }

  .stat .lbl {
    font-size: 0.6rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-top: 4px;
  }

  .dev-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.72rem;
  }

  .dev-table th {
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.08em;
    padding: 6px 10px;
    text-align: left;
    border-bottom: 1px solid var(--border);
  }

  .dev-table td {
    padding: 6px 10px;
    border-bottom: 1px solid #1e1e2a;
  }

  .dev-table tr:last-child td { border-bottom: none; }

  .pos { color: #50c880; }
  .neg { color: var(--accent2); }

  .bar-cell { width: 120px; }
  .mini-bar {
    height: 6px;
    border-radius: 3px;
    background: var(--accent);
    transition: width 0.3s;
  }

  .actions {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }

  button.action-btn {
    background: transparent;
    border: 1px solid var(--border);
    border-radius: 6px;
    color: var(--muted);
    font-family: 'Space Mono', monospace;
    font-size: 0.72rem;
    padding: 8px 16px;
    cursor: pointer;
    transition: all 0.12s;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }

  button.action-btn:hover {
    border-color: var(--accent2);
    color: var(--accent2);
  }

  .section-title {
    font-family: 'Syne', sans-serif;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    color: var(--muted);
    margin-bottom: 16px;
  }
</style>
</head>
<body>

<h1>2d6 Distribution Tracker</h1>
<p class="subtitle">Click a result to record it · See how reality matches theory</p>

<!-- Quick entry buttons -->
<div class="num-grid">
  <!-- buttons 2–12 generated by JS -->
</div>

<!-- Chart -->
<div class="card">
  <p class="section-title">Observed vs. Expected (Bell Curve)</p>
  <canvas id="chart" height="320"></canvas>
</div>

<!-- Summary stats -->
<div class="card">
  <p class="section-title">Session Stats</p>
  <div class="stats-grid" id="statsGrid"></div>
</div>

<!-- Deviation table -->
<div class="card">
  <p class="section-title">% Deviation from Expected</p>
  <table class="dev-table" id="devTable">
    <thead>
      <tr>
        <th>Roll</th>
        <th>Observed</th>
        <th>Expected %</th>
        <th>Observed %</th>
        <th>Deviation</th>
        <th class="bar-cell">Distribution</th>
      </tr>
    </thead>
    <tbody id="devBody"></tbody>
  </table>
</div>

<!-- Actions -->
<div class="actions">
  <button class="action-btn" id="undoBtn">↩ Undo Last</button>
  <button class="action-btn" id="clearBtn">✕ Clear All</button>
  <button class="action-btn" id="simBtn">⚄ Simulate 100</button>
</div>

<script>
// Expected probabilities for 2d6 (out of 36)
const WAYS = {2:1,3:2,4:3,5:4,6:5,7:6,8:5,9:4,10:3,11:2,12:1};
const TOTAL_WAYS = 36;
const ROLLS = [2,3,4,5,6,7,8,9,10,11,12];

// State
let counts = Object.fromEntries(ROLLS.map(r => [r, 0]));
let history = [];

// Build buttons
const grid = document.querySelector('.num-grid');
ROLLS.forEach(r => {
  const btn = document.createElement('button');
  btn.className = 'die-btn';
  btn.id = `btn-${r}`;
  btn.innerHTML = `<span class="label">${r}</span><span class="count" id="cnt-${r}">0</span>`;
  btn.onclick = () => record(r);
  grid.appendChild(btn);
});

function record(r) {
  counts[r]++;
  history.push(r);
  update();
}

function update() {
  // Update button counts
  ROLLS.forEach(r => {
    document.getElementById(`cnt-${r}`).textContent = counts[r];
  });
  drawChart();
  updateStats();
  updateTable();
}

// Canvas chart
const canvas = document.getElementById('chart');
const ctx = canvas.getContext('2d');

function drawChart() {
  const W = canvas.parentElement.clientWidth - 48;
  const H = 280;
  canvas.width = W;
  canvas.height = H;

  const PAD = { top: 20, right: 20, bottom: 40, left: 44 };
  const cW = W - PAD.left - PAD.right;
  const cH = H - PAD.top - PAD.bottom;

  ctx.clearRect(0, 0, W, H);

  const total = Object.values(counts).reduce((a,b) => a+b, 0);
  const maxExpPct = 6/36; // peak at 7

  // Y scale: 0 to slightly above max expected
  const maxY = Math.max(maxExpPct * 1.3, ...ROLLS.map(r => total ? counts[r]/total : 0)) * 1.1;

  const xPos = r => PAD.left + ((r - 2) / 10) * cW;
  const yPos = v => PAD.top + cH - (v / maxY) * cH;
  const barW = cW / 12;

  // Grid lines
  ctx.strokeStyle = '#1e1e2a';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const y = PAD.top + (cH / 4) * i;
    ctx.beginPath(); ctx.moveTo(PAD.left, y); ctx.lineTo(W - PAD.right, y); ctx.stroke();
  }

  // Bell curve fill
  ctx.beginPath();
  ROLLS.forEach((r, i) => {
    const exp = WAYS[r] / TOTAL_WAYS;
    const x = xPos(r);
    if (i === 0) ctx.moveTo(x, yPos(exp));
    else ctx.lineTo(x, yPos(exp));
  });
  ctx.lineTo(xPos(12), yPos(0));
  ctx.lineTo(xPos(2), yPos(0));
  ctx.closePath();
  const grad = ctx.createLinearGradient(0, PAD.top, 0, H);
  grad.addColorStop(0, 'rgba(240,192,64,0.18)');
  grad.addColorStop(1, 'rgba(240,192,64,0.02)');
  ctx.fillStyle = grad;
  ctx.fill();

  // Bell curve line
  ctx.beginPath();
  ROLLS.forEach((r, i) => {
    const exp = WAYS[r] / TOTAL_WAYS;
    const x = xPos(r);
    if (i === 0) ctx.moveTo(x, yPos(exp));
    else ctx.lineTo(x, yPos(exp));
  });
  ctx.strokeStyle = 'rgba(240,192,64,0.6)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Observed bars
  ROLLS.forEach(r => {
    if (!total) return;
    const obs = counts[r] / total;
    const x = xPos(r) - barW / 2;
    const y = yPos(obs);
    const bH = cH - (y - PAD.top);
    const exp = WAYS[r] / TOTAL_WAYS;
    const overUnder = obs > exp;
    ctx.fillStyle = overUnder ? 'rgba(80,200,128,0.7)' : 'rgba(224,80,80,0.7)';
    ctx.fillRect(x, y, barW, bH);
    ctx.strokeStyle = overUnder ? '#50c880' : '#e05050';
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, barW, bH);
  });

  // X axis labels
  ctx.fillStyle = '#666680';
  ctx.font = '11px Space Mono, monospace';
  ctx.textAlign = 'center';
  ROLLS.forEach(r => {
    ctx.fillText(r, xPos(r), H - PAD.bottom + 18);
  });

  // Y axis labels
  ctx.textAlign = 'right';
  for (let i = 0; i <= 4; i++) {
    const v = (maxY / 4) * (4 - i);
    const y = PAD.top + (cH / 4) * i;
    ctx.fillText((v * 100).toFixed(1) + '%', PAD.left - 6, y + 4);
  }

  // Legend
  const lx = PAD.left + 8, ly = PAD.top + 8;
  ctx.fillStyle = 'rgba(240,192,64,0.6)';
  ctx.fillRect(lx, ly, 16, 3);
  ctx.fillStyle = '#666680';
  ctx.textAlign = 'left';
  ctx.fillText('Expected (theory)', lx + 22, ly + 5);

  ctx.fillStyle = 'rgba(80,200,128,0.7)';
  ctx.fillRect(lx, ly + 14, 12, 10);
  ctx.fillStyle = '#666680';
  ctx.fillText('Above expected', lx + 22, ly + 22);

  ctx.fillStyle = 'rgba(224,80,80,0.7)';
  ctx.fillRect(lx + 110, ly + 14, 12, 10);
  ctx.fillText('Below expected', lx + 132, ly + 22);
}

function updateStats() {
  const total = Object.values(counts).reduce((a,b) => a+b, 0);
  let mean = 0, mode = 2, modeCount = 0;
  ROLLS.forEach(r => {
    mean += r * counts[r];
    if (counts[r] > modeCount) { modeCount = counts[r]; mode = r; }
  });
  mean = total ? (mean / total).toFixed(2) : '—';

  // Chi-square style deviation
  let totalDev = 0;
  ROLLS.forEach(r => {
    if (!total) return;
    const exp = (WAYS[r] / TOTAL_WAYS) * total;
    const obs = counts[r];
    totalDev += Math.abs(obs - exp);
  });
  const avgDev = total ? (totalDev / ROLLS.length).toFixed(2) : '—';

  const grid = document.getElementById('statsGrid');
  grid.innerHTML = `
    <div class="stat"><div class="val">${total}</div><div class="lbl">Total Rolls</div></div>
    <div class="stat"><div class="val">${mean}</div><div class="lbl">Observed Mean</div></div>
    <div class="stat"><div class="val">7</div><div class="lbl">Expected Mean</div></div>
    <div class="stat"><div class="val">${total ? mode : '—'}</div><div class="lbl">Mode</div></div>
    <div class="stat"><div class="val">${avgDev}</div><div class="lbl">Avg Abs Dev</div></div>
  `;
}

function updateTable() {
  const total = Object.values(counts).reduce((a,b) => a+b, 0);
  const maxCount = Math.max(...Object.values(counts), 1);
  const body = document.getElementById('devBody');
  body.innerHTML = '';
  ROLLS.forEach(r => {
    const expPct = (WAYS[r] / TOTAL_WAYS * 100).toFixed(2);
    const obsPct = total ? (counts[r] / total * 100).toFixed(2) : '0.00';
    const dev = total ? (counts[r] / total * 100 - WAYS[r] / TOTAL_WAYS * 100) : 0;
    const devStr = dev === 0 ? '0.00%' : (dev > 0 ? '+' : '') + dev.toFixed(2) + '%';
    const devClass = dev > 0 ? 'pos' : dev < 0 ? 'neg' : '';
    const barPct = Math.round((counts[r] / maxCount) * 100);
    body.innerHTML += `
      <tr>
        <td><strong>${r}</strong></td>
        <td>${counts[r]}</td>
        <td>${expPct}%</td>
        <td>${obsPct}%</td>
        <td class="${devClass}">${devStr}</td>
        <td class="bar-cell"><div class="mini-bar" style="width:${barPct}%"></div></td>
      </tr>`;
  });
}

// Controls
document.getElementById('undoBtn').onclick = () => {
  if (!history.length) return;
  const last = history.pop();
  counts[last]--;
  update();
};

document.getElementById('clearBtn').onclick = () => {
  counts = Object.fromEntries(ROLLS.map(r => [r, 0]));
  history = [];
  update();
};

document.getElementById('simBtn').onclick = () => {
  for (let i = 0; i < 100; i++) {
    const roll = Math.ceil(Math.random()*6) + Math.ceil(Math.random()*6);
    counts[roll]++;
    history.push(roll);
  }
  update();
};

// Init
update();
window.addEventListener('resize', drawChart);
</script>
</body>
</html>
